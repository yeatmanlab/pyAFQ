#!/usr/bin/env python

from argparse import ArgumentParser

import numpy as np
import dipy.core.gradients as dpg

description = """Create a signal prediction from DKI or DTI params."""
parser = ArgumentParser(description=description)

parser.add_argument("-t", "--model_type", metavar="model_type", required=True,
        choices=["dki", "dti"], help="fitting method ('dki' or 'dti')")

parser.add_argument("-p", "--params", metavar="param_file", required=True,
        help="path to file containing DKI params")

parser.add_argument("-l", "--bval", nargs="+", required=True,
        help="""b-value file or list of b-value files
                (separated by spaces)""")

parser.add_argument("-c", "--bvec", nargs="+", required=True,
        help="""b-vector file or list of b-vector files
                (separated by spaces)""")

parser.add_argument("-o", "--out_dir",
        help="""full path to directory for files to be saved
                (will be created if it doesn't exist)""")

parser.add_argument("-s", "--S0_file",
        help="""path to file containing S0 measurements
                to use in prediction""")

parser.add_argument('-b', '--b0_threshold', help="b0 threshold",
        default=0, type=float)

args = parser.parse_args()

bvals = []
bvecs = []
for bval_file, bvec_file in zip(args.bval, args.bvec):
    bvals.append(np.loadtxt(bval_file))
    bvecs.append(np.loadtxt(bvec_file))

gtab = dpg.gradient_table(np.concatenate(bvals),
        np.concatenate(bvecs, -1),
        b0_threshold=args.b0_threshold)

if args.model_type == "dki":
    from AFQ import dki as model_type
else:
    from AFQ import dti as model_type

model_type.predict(args.params, gtab, S0_file=args.S0_file,
        out_dir=args.out_dir)
