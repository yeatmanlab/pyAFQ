:py:mod:`AFQ.definitions.mapping`
=================================

.. py:module:: AFQ.definitions.mapping


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   AFQ.definitions.mapping.FnirtMap
   AFQ.definitions.mapping.SynMap
   AFQ.definitions.mapping.SlrMap
   AFQ.definitions.mapping.AffMap




.. py:class:: FnirtMap(warp_path=None, space_path=None, warp_suffix=None, space_suffix=None, warp_filters={}, space_filters={})


   Bases: :py:obj:`AFQ.definitions.utils.Definition`

   
   Use an existing FNIRT map. Expects a warp file
   and an image file for each subject / session; image file
   is used as src space for warp.


   :Parameters:

       **warp_path** : str, optional
           path to file to get warp from. Use this or warp_suffix.
           Default: None

       **space_path** : str, optional
           path to file to get warp from. Use this or space_suffix.
           Default: None

       **warp_suffix** : str, optional
           suffix to pass to bids_layout.get() to identify the warp file.
           Default: None

       **space_suffix** : str, optional
           suffix to pass to bids_layout.get() to identify the space file.
           Default: None

       **warp_filters** : str, optional
           Additional filters to pass to bids_layout.get() to identify
           the warp file.
           Default: {}

       **space_filters** : str, optional
           Additional filters to pass to bids_layout.get() to identify
           the space file.
           Default: {}









   .. rubric:: Notes

   If you have an existing mapping calculated using Fnirt,
   you can pass bids filters to :class:`AFQ.definitions.mapping.FnirtMap`
   and pyAFQ will find and use that mapping.


   .. rubric:: Examples

   fnirt_map = FnirtMap(
       warp_suffix="warp",
       space_suffix="MNI",
       warp_filters={"scope": "TBSS"},
       space_filters={"scope": "TBSS"})
   api.GroupAFQ(mapping=fnirt_map)



   ..
       !! processed by numpydoc !!
   .. py:method:: find_path(bids_layout, from_path, subject, session, required=True)


   .. py:method:: get_for_subses(base_fname, dwi, dwi_data_file, reg_subject, reg_template)



.. py:class:: SynMap(use_prealign=True, affine_kwargs={}, syn_kwargs={})


   Bases: :py:obj:`GeneratedMapMixin`, :py:obj:`AFQ.definitions.utils.Definition`

   
   Calculate a Syn registration for each subject/session
   using reg_subject and reg_template.


   :Parameters:

       **use_prealign** : bool
           Whether to perform a linear pre-registration.
           Default: True

       **affine_kwargs** : dictionary, optional
           Parameters to pass to affine_registration
           in dipy.align, which does the linear pre-alignment.
           Only used if use_prealign is True.
           Default: {}

       **syn_kwargs** : dictionary, optional
           Parameters to pass to syn_registration
           in dipy.align, which does the SyN alignment.
           Default: {}









   .. rubric:: Notes

   The default mapping class is to
   use Symmetric Diffeomorphic Image Registration (SyN).
   This is done with an optional linear pre-alignment by default.
   The parameters of the pre-alginment can be specified when
   initializing the SynMap.


   .. rubric:: Examples

   api.GroupAFQ(mapping=SynMap())



   ..
       !! processed by numpydoc !!
   .. py:method:: gen_mapping(base_fname, reg_subject, reg_template, subject_sls, template_sls, reg_prealign)



.. py:class:: SlrMap(slr_kwargs={})


   Bases: :py:obj:`GeneratedMapMixin`, :py:obj:`AFQ.definitions.utils.Definition`

   
   Calculate a SLR registration for each subject/session
   using reg_subject and reg_template.


   :Parameters:

       **slr_kwargs** : dictionary, optional
           Parameters to pass to whole_brain_slr
           in dipy, which does the SLR alignment.
           Default: {}









   .. rubric:: Notes

   Use this class to tell pyAFQ to use
   Streamline-based Linear Registration (SLR) 
   for registration. Note that the reg_template and reg_subject
   parameters passed to :class:`AFQ.api.group.GroupAFQ` should
   be streamlines when using this registration.


   .. rubric:: Examples

   api.GroupAFQ(mapping=SlrMap())



   ..
       !! processed by numpydoc !!
   .. py:method:: gen_mapping(base_fname, reg_template, reg_subject, subject_sls, template_sls, reg_prealign)



.. py:class:: AffMap(affine_kwargs={})


   Bases: :py:obj:`GeneratedMapMixin`, :py:obj:`AFQ.definitions.utils.Definition`

   
   Calculate an affine registration for each subject/session
   using reg_subject and reg_template.


   :Parameters:

       **affine_kwargs** : dictionary, optional
           Parameters to pass to affine_registration
           in dipy.align, which does the linear pre-alignment.
           Default: {}









   .. rubric:: Notes

   This will only perform a linear alignment for registration.


   .. rubric:: Examples

   api.GroupAFQ(mapping=AffMap())



   ..
       !! processed by numpydoc !!
   .. py:method:: gen_mapping(base_fname, reg_subject, reg_template, subject_sls, template_sls, reg_prealign)



