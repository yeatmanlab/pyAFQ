:py:mod:`AFQ.definitions.mask`
==============================

.. py:module:: AFQ.definitions.mask

.. autoapi-nested-parse::

   
   ..
       !! processed by numpydoc !!


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   AFQ.definitions.mask.MaskFile
   AFQ.definitions.mask.FullMask
   AFQ.definitions.mask.RoiMask
   AFQ.definitions.mask.B0Mask
   AFQ.definitions.mask.LabelledMaskFile
   AFQ.definitions.mask.ThresholdedMaskFile
   AFQ.definitions.mask.ScalarMask
   AFQ.definitions.mask.ThresholdedScalarMask




.. py:class:: MaskFile(path=None, suffix=None, filters={})

   Bases: :py:obj:`AFQ.definitions.utils.Definition`

   
   Define a mask based on a file.
   Does not apply any labels or thresholds;
   Generates mask with floating point data.
   Useful for seed and stop masks, where threshold can be applied
   after interpolation (see example).


   :Parameters:

       **path** : str, optional
           path to file to get mask from. Use this or suffix.
           Default: None

       **suffix** : str, optional
           suffix to pass to bids_layout.get() to identify the file.
           Default: None

       **filters** : str, optional
           Additional filters to pass to bids_layout.get() to identify
           the file.
           Default: {}











   .. rubric:: Examples

   seed_mask = MaskFile(
       suffix="WM",
       filters={"scope":"dmriprep"})
   api.GroupAFQ(tracking_params={"seed_mask": seed_mask,
                               "seed_threshold": 0.1})



   ..
       !! processed by numpydoc !!
   .. py:method:: find_path(self, bids_layout, from_path, subject, session)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_path_data_affine(self, subses_dict, bids_info)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: apply_conditions(self, mask_data_orig, mask_file)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_mask_getter(self)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_brain_mask(self, subses_dict, bids_info, dwi_affine, b0_file)

      
















      ..
          !! processed by numpydoc !!


.. py:class:: FullMask

   Bases: :py:obj:`AFQ.definitions.utils.Definition`

   
   Define a mask which covers a full volume.













   .. rubric:: Examples

   brain_mask_definition = FullMask()



   ..
       !! processed by numpydoc !!
   .. py:method:: find_path(self, bids_layout, from_path, subject, session)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_mask_getter(self)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_brain_mask(self, subses_dict, bids_info, dwi_affine, b0_file)

      
















      ..
          !! processed by numpydoc !!


.. py:class:: RoiMask(use_presegment=False)

   Bases: :py:obj:`AFQ.definitions.utils.Definition`

   
   Define a mask which is all ROIs or'd together.













   .. rubric:: Examples

   seed_mask = RoiMask()
   api.GroupAFQ(tracking_params={"seed_mask": seed_mask})



   ..
       !! processed by numpydoc !!
   .. py:method:: find_path(self, bids_layout, from_path, subject, session)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_mask_getter(self)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_brain_mask(self, subses_dict, bids_info, dwi_affine, b0_file)

      
















      ..
          !! processed by numpydoc !!


.. py:class:: B0Mask(median_otsu_kwargs={})

   Bases: :py:obj:`AFQ.definitions.utils.Definition`

   
   Define a mask using b0 and dipy's median_otsu.


   :Parameters:

       **median_otsu_kwargs: dict, optional**
           Optional arguments to pass into dipy's median_otsu.
           Default: {}











   .. rubric:: Examples

   brain_mask_definition = B0Mask()
   api.GroupAFQ(brain_mask_definition=brain_mask_definition)



   ..
       !! processed by numpydoc !!
   .. py:method:: find_path(self, bids_layout, from_path, subject, session)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_mask_getter(self)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_brain_mask(self, subses_dict, bids_info, dwi_affine, b0_file)

      
















      ..
          !! processed by numpydoc !!


.. py:class:: LabelledMaskFile(path=None, suffix=None, filters={}, inclusive_labels=None, exclusive_labels=None, combine='or')

   Bases: :py:obj:`MaskFile`, :py:obj:`CombineMaskMixin`

   
   Define a mask based on labels in a file.


   :Parameters:

       **path** : str, optional
           path to file to get mask from. Use this or suffix.
           Default: None

       **suffix** : str, optional
           suffix to pass to bids_layout.get() to identify the file.
           Default: None

       **filters** : str, optional
           Additional filters to pass to bids_layout.get() to identify
           the file.
           Default: {}

       **inclusive_labels** : list of ints, optional
           The labels from the file to include from the boolean mask.
           If None, no inclusive labels are applied.

       **exclusive_labels** : lits of ints, optional
           The labels from the file to exclude from the boolean mask.
           If None, no exclusive labels are applied.
           Default: None.

       **combine** : str, optional
           How to combine the boolean masks generated by inclusive_labels
           and exclusive_labels. If "and", they will be and'd together.
           If "or", they will be or'd.
           Note: in this class, you will most likely want to either set
           inclusive_labels or exclusive_labels, not both,
           so combine will not matter.
           Default: "or"











   .. rubric:: Examples

   brain_mask_definition = LabelledMaskFile(
       suffix="aseg",
       filters={"scope": "dmriprep"},
       exclusive_labels=[0])
   api.GroupAFQ(brain_mask_definition=brain_mask_definition)



   ..
       !! processed by numpydoc !!
   .. py:method:: apply_conditions(self, mask_data_orig, mask_file)

      
















      ..
          !! processed by numpydoc !!


.. py:class:: ThresholdedMaskFile(path=None, suffix=None, filters={}, lower_bound=None, upper_bound=None, combine='and')

   Bases: :py:obj:`MaskFile`, :py:obj:`CombineMaskMixin`

   
   Define a mask based on thresholding a file.
   Note that this should not be used to directly make a seed mask
   or a stop mask. In those cases, consider thresholding after
   interpolation, as in the example for MaskFile.


   :Parameters:

       **path** : str, optional
           path to file to get mask from. Use this or suffix.
           Default: None

       **suffix** : str, optional
           suffix to pass to bids_layout.get() to identify the file.
           Default: None

       **filters** : str, optional
           Additional filters to pass to bids_layout.get() to identify
           the file.
           Default: {}

       **lower_bound** : float, optional
           Lower bound to generate boolean mask from data in the file.
           If None, no lower bound is applied.
           Default: None.

       **upper_bound** : float, optional
           Upper bound to generate boolean mask from data in the file.
           If None, no upper bound is applied.
           Default: None.

       **combine** : str, optional
           How to combine the boolean masks generated by lower_bound
           and upper_bound. If "and", they will be and'd together.
           If "or", they will be or'd.
           Default: "and"











   .. rubric:: Examples

   brain_mask_definition = ThresholdedMaskFile(
       suffix="BM",
       filters={"scope":"dmriprep"},
       lower_bound=0.1)
   api.GroupAFQ(brain_mask_definition=brain_mask_definition)



   ..
       !! processed by numpydoc !!
   .. py:method:: apply_conditions(self, mask_data_orig, mask_file)

      
















      ..
          !! processed by numpydoc !!


.. py:class:: ScalarMask(scalar)

   Bases: :py:obj:`AFQ.definitions.utils.Definition`

   
   Define a mask based on a scalar.
   Does not apply any labels or thresholds;
   Generates mask with floating point data.
   Useful for seed and stop masks, where threshold can be applied
   after interpolation (see example).


   :Parameters:

       **scalar** : str
           Scalar to threshold.
           Can be one of "dti_fa", "dti_md", "dki_fa", "dki_md".











   .. rubric:: Examples

   seed_mask = ScalarMask(
       "dti_fa",
       scope="dmriprep")
   api.GroupAFQ(tracking_params={
       "seed_mask": seed_mask,
       "seed_threshold": 0.2})



   ..
       !! processed by numpydoc !!
   .. py:method:: find_path(self, bids_layout, from_path, subject, session)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_mask_getter(self)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_brain_mask(self, subses_dict, bids_info, dwi_affine, b0_file)

      
















      ..
          !! processed by numpydoc !!


.. py:class:: ThresholdedScalarMask(scalar, lower_bound=None, upper_bound=None, combine='and')

   Bases: :py:obj:`ThresholdedMaskFile`, :py:obj:`ScalarMask`

   
   Define a mask based on thresholding a scalar mask.
   Note that this should not be used to directly make a seed mask
   or a stop mask. In those cases, consider thresholding after
   interpolation, as in the example for ScalarMask.


   :Parameters:

       **scalar** : str
           Scalar to threshold.
           Can be one of "dti_fa", "dti_md", "dki_fa", "dki_md".

       **lower_bound** : float, optional
           Lower bound to generate boolean mask from data in the file.
           If None, no lower bound is applied.
           Default: None.

       **upper_bound** : float, optional
           Upper bound to generate boolean mask from data in the file.
           If None, no upper bound is applied.
           Default: None.

       **combine** : str, optional
           How to combine the boolean masks generated by lower_bound
           and upper_bound. If "and", they will be and'd together.
           If "or", they will be or'd.
           Default: "and"











   .. rubric:: Examples

   seed_mask = ThresholdedScalarMask(
       "dti_fa",
       lower_bound=0.2)
   api.GroupAFQ(tracking_params={"seed_mask": seed_mask})



   ..
       !! processed by numpydoc !!

