:py:mod:`AFQ.definitions.mapping`
=================================

.. py:module:: AFQ.definitions.mapping

.. autoapi-nested-parse::

   
   ..
       !! processed by numpydoc !!


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   AFQ.definitions.mapping.FnirtMap
   AFQ.definitions.mapping.SynMap
   AFQ.definitions.mapping.SlrMap
   AFQ.definitions.mapping.AffMap




.. py:class:: FnirtMap(warp_path=None, space_path=None, warp_suffix=None, space_suffix=None, warp_filters={}, space_filters={})

   Bases: :py:obj:`AFQ.definitions.utils.Definition`

   
   Use an existing FNIRT map. Expects a warp file
   and an image file for each subject / session; image file
   is used as src space for warp.


   :Parameters:

       **warp_path** : str, optional
           path to file to get warp from. Use this or warp_suffix.
           Default: None

       **space_path** : str, optional
           path to file to get warp from. Use this or space_suffix.
           Default: None

       **warp_suffix** : str, optional
           suffix to pass to bids_layout.get() to identify the warp file.
           Default: None

       **space_suffix** : str, optional
           suffix to pass to bids_layout.get() to identify the space file.
           Default: None

       **warp_filters** : str, optional
           Additional filters to pass to bids_layout.get() to identify
           the warp file.
           Default: {}

       **space_filters** : str, optional
           Additional filters to pass to bids_layout.get() to identify
           the space file.
           Default: {}











   .. rubric:: Examples

   fnirt_map = FnirtMap(
       warp_suffix="warp",
       space_suffix="MNI",
       warp_filters={"scope": "TBSS"},
       space_filters={"scope": "TBSS"})
   api.GroupAFQ(mapping=fnirt_map)



   ..
       !! processed by numpydoc !!
   .. py:method:: find_path(self, bids_layout, from_path, subject, session)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_for_subses(self, base_fname, dwi, bids_info, reg_subject, reg_template)

      
















      ..
          !! processed by numpydoc !!


.. py:class:: SynMap(use_prealign=True, affine_kwargs={}, syn_kwargs={})

   Bases: :py:obj:`GeneratedMapMixin`, :py:obj:`AFQ.definitions.utils.Definition`

   
   Calculate a Syn registration for each subject/session
   using reg_subject and reg_template.


   :Parameters:

       **use_prealign** : bool
           Whether to perform a linear pre-registration.
           Default: True

       **affine_kwargs** : dictionary, optional
           Parameters to pass to affine_registration
           in dipy.align, which does the linear pre-alignment.
           Only used if use_prealign is True.
           Default: {}

       **syn_kwargs** : dictionary, optional
           Parameters to pass to syn_registration
           in dipy.align, which does the SyN alignment.
           Default: {}

       **Examples**
           ..

       **--------**
           ..

       **api.GroupAFQ(mapping=SynMap())**
           ..














   ..
       !! processed by numpydoc !!
   .. py:method:: find_path(self, bids_layout, from_path, subject, session)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: gen_mapping(self, base_fname, reg_subject, reg_template, subject_sls, template_sls, reg_prealign)

      
















      ..
          !! processed by numpydoc !!


.. py:class:: SlrMap(slr_kwargs={})

   Bases: :py:obj:`GeneratedMapMixin`, :py:obj:`AFQ.definitions.utils.Definition`

   
   Calculate a SLR registration for each subject/session
   using reg_subject and reg_template.

   slr_kwargs : dictionary, optional
       Parameters to pass to whole_brain_slr
       in dipy, which does the SLR alignment.
       Default: {}












   .. rubric:: Examples

   api.GroupAFQ(mapping=SlrMap())



   ..
       !! processed by numpydoc !!
   .. py:method:: find_path(self, bids_layout, from_path, subject, session)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: gen_mapping(self, base_fname, reg_template, reg_subject, subject_sls, template_sls, reg_prealign)

      
















      ..
          !! processed by numpydoc !!


.. py:class:: AffMap(affine_kwargs={})

   Bases: :py:obj:`GeneratedMapMixin`, :py:obj:`AFQ.definitions.utils.Definition`

   
   Calculate an affine registration for each subject/session
   using reg_subject and reg_template.

   affine_kwargs : dictionary, optional
       Parameters to pass to affine_registration
       in dipy.align, which does the linear pre-alignment.
       Default: {}












   .. rubric:: Examples

   api.GroupAFQ(mapping=AffMap())



   ..
       !! processed by numpydoc !!
   .. py:method:: find_path(self, bids_layout, from_path, subject, session)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: gen_mapping(self, base_fname, reg_subject, reg_template, subject_sls, template_sls, reg_prealign)

      
















      ..
          !! processed by numpydoc !!


