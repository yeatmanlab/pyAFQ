:py:mod:`AFQ.api.bundle_dict`
=============================

.. py:module:: AFQ.api.bundle_dict


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   AFQ.api.bundle_dict.BundleDict
   AFQ.api.bundle_dict.PediatricBundleDict




.. py:class:: BundleDict(bundle_info=BUNDLES, seg_algo='afq', resample_to=None, resample_subject_to=False, keep_in_memory=False)

   Bases: :py:obj:`collections.abc.MutableMapping`

   
   Create a bundle dictionary, needed for the segmentation.


   :Parameters:

       **bundle_info** : list or dict, optional
           A list of the bundles to be used, or a dictionary defining
           custom bundles. See `Defining Custom Bundle Dictionaries`
           in the `usage` section of pyAFQ's documentation for details.
           Default: AFQ.api.bundle_dict.BUNDLES

       **seg_algo: One of {"afq", "reco", "reco16", "reco80"}**
           The bundle segmentation algorithm to use.
               "afq" : Use waypoint ROIs + probability maps, as described
               in [Yeatman2012]_
               "reco" / "reco16" : Use Recobundles [Garyfallidis2017]_
               with a 16-bundle set.
               "reco80": Use Recobundles with an 80-bundle set.

       **resample_to** : Nifti1Image or bool, optional
           If there are bundles in bundle_info with the 'space' attribute
           set to 'template', or with no 'space' attribute,
           their images (all ROIs and probability maps)
           will be resampled to the affine and shape of this image.
           If None, the MNI template will be used.
           If False, no resampling will be done.
           Default: None

       **resample_subject_to** : Nifti1Image or bool, optional
           If there are bundles in bundle_info with the 'space' attribute
           set to 'subject', their images (all ROIs and probability maps)
           will be resampled to the affine and shape of this image.
           If False, no resampling will be done.
           Default: None

       **keep_in_memory** : bool, optional
           Whether, once loaded, all ROIs and probability maps will stay
           loaded in memory within this object. By default, ROIs are loaded
           into memory on demand and no references to ROIs are kept, other
           than their paths. The default 18 bundles use ~6GB when all loaded.
           Default: False











   .. rubric:: Examples

   # import OR ROIs and create a custom bundle dict
   # from them
   import AFQ.data.fetch as afd
   or_rois = afd.read_or_templates()

   bundles = BundleDict({
       "L_OR": {
           "include": [
               or_rois["left_OR_1"],  # these can be paths to Nifti files
               or_rois["left_OR_2"]],  # or they can Nifti images
           "exclude": [
               or_rois["left_OP_MNI"],
               or_rois["left_TP_MNI"],
               or_rois["left_pos_thal_MNI"]],
           "start": or_rois['left_thal_MNI'],
           "end": or_rois['left_V1_MNI'],
           "cross_midline": False,
       },
       "R_OR": {
           "include": [
               or_rois["right_OR_1"],
               or_rois["right_OR_2"]],
           "exclude": [
               or_rois["right_OP_MNI"],
               or_rois["right_TP_MNI"],
               or_rois["right_pos_thal_MNI"]],
           "start": or_rois['right_thal_MNI'],
           "end": or_rois['right_V1_MNI'],
           "cross_midline": False
       }
   })



   ..
       !! processed by numpydoc !!
   .. py:method:: load_templates()

      
      Loads templates for generating bundle dictionaries
      from bundle names.
















      ..
          !! processed by numpydoc !!

   .. py:method:: _gen(bundle_name)

      
      Given a bundle name, load its
      bundle's dictionary describing the bundle.
















      ..
          !! processed by numpydoc !!

   .. py:method:: gen_all()

      
      If bundle_info is a list of names, this will load
      each bundle's dictionary describing the bundle.
















      ..
          !! processed by numpydoc !!

   .. py:method:: __getitem__(key)


   .. py:method:: __setitem__(key, item)


   .. py:method:: __len__()


   .. py:method:: __delitem__(key)


   .. py:method:: __iter__()


   .. py:method:: copy()

      
      Generates a copy of this BundleDict where the internal dictionary
      is a copy of this BundleDict's internal dictionary.
      Useful if you want to add or remove bundles from a copy
      of a BundleDict.



      :Returns:

          **bundle_dict** : BundleDict
              Euclidean norms of vectors.













      ..
          !! processed by numpydoc !!

   .. py:method:: apply_to_rois(b_name, func, *args, **kwargs)

      
      Applies some transformation to all ROIs (include, exclude, end, start)
      and the prob_map in a given bundle.


      :Parameters:

          **b_name** : name
              bundle name of bundle whose ROIs will be transformed.

          **func** : function
              function whose first argument must be a Nifti1Image and which
              returns a Nifti1Image

          **\*args**
              Additional arguments for func

          **\*\*kwargs**
              Optional arguments for func

      :Returns:

          Dictionary containing the old values of all ROIs and prob_map
              ..













      ..
          !! processed by numpydoc !!

   .. py:method:: _resample_roi(b_name)

      
      Given a bundle name, resample all ROIs and prob maps
      into either template or subject space for that bundle,
      depending on its "space" attribute.


      :Parameters:

          **b_name** : str
              Name of the bundle to be resampled.














      ..
          !! processed by numpydoc !!

   .. py:method:: __add__(other)



.. py:class:: PediatricBundleDict(bundle_info=PEDIATRIC_BUNDLES, seg_algo='afq', resample_to=None, resample_subject_to=False, keep_in_memory=False)

   Bases: :py:obj:`BundleDict`

   
   Create a bundle dictionary, needed for the segmentation.


   :Parameters:

       **bundle_info** : list or dict, optional
           A list of the bundles to be used, or a dictionary defining
           custom bundles. See `Defining Custom Bundle Dictionaries`
           in the `usage` section of pyAFQ's documentation for details.
           Default: AFQ.api.bundle_dict.BUNDLES

       **seg_algo: One of {"afq", "reco", "reco16", "reco80"}**
           The bundle segmentation algorithm to use.
               "afq" : Use waypoint ROIs + probability maps, as described
               in [Yeatman2012]_
               "reco" / "reco16" : Use Recobundles [Garyfallidis2017]_
               with a 16-bundle set.
               "reco80": Use Recobundles with an 80-bundle set.

       **resample_to** : Nifti1Image or bool, optional
           If there are bundles in bundle_info with the 'space' attribute
           set to 'template', or with no 'space' attribute,
           their images (all ROIs and probability maps)
           will be resampled to the affine and shape of this image.
           If None, the MNI template will be used.
           If False, no resampling will be done.
           Default: None

       **resample_subject_to** : Nifti1Image or bool, optional
           If there are bundles in bundle_info with the 'space' attribute
           set to 'subject', their images (all ROIs and probability maps)
           will be resampled to the affine and shape of this image.
           If False, no resampling will be done.
           Default: None

       **keep_in_memory** : bool, optional
           Whether, once loaded, all ROIs and probability maps will stay
           loaded in memory within this object. By default, ROIs are loaded
           into memory on demand and no references to ROIs are kept, other
           than their paths. The default 18 bundles use ~6GB when all loaded.
           Default: False











   .. rubric:: Examples

   # import OR ROIs and create a custom bundle dict
   # from them
   import AFQ.data.fetch as afd
   or_rois = afd.read_or_templates()

   bundles = BundleDict({
       "L_OR": {
           "include": [
               or_rois["left_OR_1"],  # these can be paths to Nifti files
               or_rois["left_OR_2"]],  # or they can Nifti images
           "exclude": [
               or_rois["left_OP_MNI"],
               or_rois["left_TP_MNI"],
               or_rois["left_pos_thal_MNI"]],
           "start": or_rois['left_thal_MNI'],
           "end": or_rois['left_V1_MNI'],
           "cross_midline": False,
       },
       "R_OR": {
           "include": [
               or_rois["right_OR_1"],
               or_rois["right_OR_2"]],
           "exclude": [
               or_rois["right_OP_MNI"],
               or_rois["right_TP_MNI"],
               or_rois["right_pos_thal_MNI"]],
           "start": or_rois['right_thal_MNI'],
           "end": or_rois['right_V1_MNI'],
           "cross_midline": False
       }
   })



   ..
       !! processed by numpydoc !!
   .. py:method:: load_templates()

      
      Loads templates for generating bundle dictionaries
      from bundle names.
















      ..
          !! processed by numpydoc !!


