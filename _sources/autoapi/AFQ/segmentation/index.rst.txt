:mod:`AFQ.segmentation`
=======================

.. py:module:: AFQ.segmentation


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   AFQ.segmentation.Segmentation



Functions
~~~~~~~~~

.. autoapisummary::

   AFQ.segmentation.clean_bundle
   AFQ.segmentation.clean_by_endpoints



.. class:: Segmentation(nb_points=False, nb_streamlines=False, seg_algo='AFQ', reg_algo=None, clip_edges=False, parallel_segmentation={'n_jobs': -1, 'engine': 'joblib', 'backend': 'loky'}, progressive=True, greater_than=50, rm_small_clusters=50, model_clust_thr=1.25, reduction_thr=25, refine=False, pruning_thr=12, b0_threshold=50, prob_threshold=0, dist_to_waypoint=None, rng=None, return_idx=False, presegment_bundle_dict=None, presegment_kawrgs={}, filter_by_endpoints=True, endpoint_info=None, dist_to_atlas=4, save_intermediates=None)


   .. method:: _read_tg(self, tg=None)


   .. method:: segment(self, bundle_dict, tg, fdata=None, fbval=None, fbvec=None, mapping=None, reg_prealign=None, reg_template=None, b0_threshold=50, img_affine=None, reset_tg_space=False)

      Segment streamlines into bundles based on either waypoint ROIs
      [R03e71c6d7dc6-Yeatman2012]_ or RecoBundles [Garyfallidis2017]_.
      Parameters
      ----------
      bundle_dict: dict or AFQ.api.BundleDict
          Meta-data for the segmentation. The format is something like::
              {'name': {'ROIs':[img1, img2],
              'rules':[True, True]},
              'prob_map': img3,
              'cross_midline': False}
      tg : StatefulTractogram
          Bundles to segment
      fdata, fbval, fbvec : str
          Full path to data, bvals, bvecs
      mapping : DiffeomorphicMap object, str or nib.Nifti1Image, optional.
          A mapping between DWI space and a template. If None, mapping will
          be registered from data used in prepare_img. Default: None.
      reg_prealign : array, optional.
          The linear transformation to be applied to align input images to
          the reference space before warping under the deformation field.
          Default: None.
      reg_template : str or nib.Nifti1Image, optional.
          Template to use for registration. Default: MNI T2.
      img_affine : array, optional.
          The spatial transformation from the measurement to the scanner
          space.
      reset_tg_space : bool, optional
          Whether to reset the space of the input tractogram after
          segmentation is complete. Default: False.



      :Returns:

          **dict** : Where keys are bundle names, values are tractograms of
              these bundles.









      .. rubric:: References

      .. [R03e71c6d7dc6-Yeatman2012] Yeatman, Jason D., Robert F. Dougherty, Nathaniel J.
      Myall, Brian A. Wandell, and Heidi M. Feldman. 2012. "Tract Profiles of
      White Matter Properties: Automating Fiber-Tract Quantification"
      PloS One 7 (11): e49790.
      .. [R03e71c6d7dc6-Garyfallidis17] Garyfallidis et al. Recognition of white matter
      bundles using local and global streamline-based registration and
      clustering, Neuroimage, 2017.

      .. only:: latex

         [R03e71c6d7dc6-Yeatman2012]_, [R03e71c6d7dc6-Garyfallidis17]_




      ..
          !! processed by numpydoc !!


   .. method:: prepare_img(self, fdata, fbval, fbvec)

      Prepare image data from DWI data.
      Parameters
      ----------
      fdata, fbval, fbvec : str
          Full path to data, bvals, bvecs
















      ..
          !! processed by numpydoc !!


   .. method:: prepare_map(self, mapping=None, reg_prealign=None, reg_template=None)

      Set mapping between DWI space and a template.
      Parameters
      ----------
      mapping : DiffeomorphicMap object, str or nib.Nifti1Image, optional.
          A mapping between DWI space and a template.
          If None, mapping will be registered from data used in prepare_img.
          Default: None.
      reg_template : str or nib.Nifti1Image, optional.
          Template to use for registration (defaults to the MNI T2)
          Default: None.
      reg_prealign : array, optional.
          The linear transformation to be applied to align input images to
          the reference space before warping under the deformation field.
          Default: None.
















      ..
          !! processed by numpydoc !!


   .. method:: cross_streamlines(self, tg=None, template=None, low_coord=10)

      Classify the streamlines by whether they cross the midline.
      Creates a crosses attribute which is an array of booleans. Each boolean
      corresponds to a streamline, and is whether or not that streamline
      crosses the midline.
      Parameters
      ----------
      tg : StatefulTractogram class instance.
      template : nibabel.Nifti1Image class instance
          An affine transformation into a template space.
















      ..
          !! processed by numpydoc !!


   .. method:: _get_bundle_info(self, bundle_idx, bundle, vox_dim, tol)

      Get fiber probabilites and ROIs for a given bundle.
















      ..
          !! processed by numpydoc !!


   .. method:: _return_empty(self, bundle)

      Helper function for segment_afq, to return an empty dict under
      some conditions.
















      ..
          !! processed by numpydoc !!


   .. method:: segment_afq(self, tg=None)

      Assign streamlines to bundles using the waypoint ROI approach
      Parameters
      ----------
      tg : StatefulTractogram class instance
















      ..
          !! processed by numpydoc !!


   .. method:: move_streamlines(self, tg, reg_algo='slr')

      Streamline-based registration of a whole-brain tractogram to
      the MNI whole-brain atlas.

      registration_algo : str
          "slr" or "syn"















      ..
          !! processed by numpydoc !!


   .. method:: segment_reco(self, tg=None)

      Segment streamlines using the RecoBundles algorithm [Garyfallidis2017]
      Parameters
      ----------
      tg : StatefulTractogram class instance
          A whole-brain tractogram to be segmented.
      Returns
      -------
      fiber_groups : dict
          Keys are names of the bundles, values are Streamline objects.
          The streamlines in each object have all been oriented to have the
          same orientation (using `dts.orient_by_streamline`).
















      ..
          !! processed by numpydoc !!



.. function:: clean_bundle(tg, n_points=100, clean_rounds=5, distance_threshold=5, length_threshold=4, min_sl=20, stat='mean', return_idx=False)

   Clean a segmented fiber group based on the Mahalnobis distance of
   each streamline


   :Parameters:

       **tg** : StatefulTractogram class instance
           A whole-brain tractogram to be segmented.

       **n_points** : int, optional
           Number of points to resample streamlines to.
           Default: 100

       **clean_rounds** : int, optional.
           Number of rounds of cleaning based on the Mahalanobis distance from
           the mean of extracted bundles. Default: 5

       **distance_threshold** : float, optional.
           Threshold of cleaning based on the Mahalanobis distance (the units are
           standard deviations). Default: 5.

       **length_threshold: float, optional**
           Threshold for cleaning based on length (in standard deviations). Length
           of any streamline should not be *more* than this number of stdevs from
           the mean length.

       **min_sl** : int, optional.
           Number of streamlines in a bundle under which we will
           not bother with cleaning outliers. Default: 20.

       **stat** : callable or str, optional.
           The statistic of each node relative to which the Mahalanobis is
           calculated. Default: `np.mean` (but can also use median, etc.)

       **return_idx** : bool
           Whether to return indices in the original streamlines.
           Default: False.

       **Returns**
           ..

       **-------**
           ..

       **A StatefulTractogram class instance containing only the streamlines**
           ..

       **that have a Mahalanobis distance smaller than `clean_threshold` from**
           ..

       **the mean of each one of the nodes.**
           ..














   ..
       !! processed by numpydoc !!


.. function:: clean_by_endpoints(streamlines, targets0, targets1, tol=None, atlas=None, return_idx=False)

   Clean a collection of streamlines based on their two endpoints
   Filters down to only include items that have their starting points close to
   the targets0 and ending points close to targets1
   Parameters
   ----------
   streamlines : sequence of 3XN_i arrays The collection of streamlines to
       filter down to.
   targets0, target1: sequences or Nx3 arrays or None.
       The targets. Numerical values in the atlas array for targets for the
       first and last node in each streamline respectively, or NX3 arrays with
       each row containing the indices for these locations in the atlas.
       If provided a None, this means no restriction on that end.
   tol : float, optional A distance tolerance (in units that the coordinates
       of the streamlines are represented in). Default: 0, which means that
       the endpoint is exactly in the coordinate of the target ROI.
   atlas : 3D array or Nifti1Image class instance with a 3D array, optional.
       Contains numerical values for ROIs. Default: if not provided, assume
       that targets0 and targets1 are both arrays of indices, and this
       information is not needed.
   Yields
   -------
   Generator of the filtered collection
















   ..
       !! processed by numpydoc !!


