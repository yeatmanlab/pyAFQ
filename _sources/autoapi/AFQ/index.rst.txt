:mod:`AFQ`
==========

.. py:module:: AFQ


Subpackages
-----------
.. toctree::
   :titlesonly:
   :maxdepth: 3

   definitions/index.rst
   models/index.rst
   utils/index.rst
   viz/index.rst


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   api/index.rst
   bundles/index.rst
   data/index.rst
   registration/index.rst
   segmentation/index.rst
   tractography/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   AFQ.AFQ



Functions
~~~~~~~~~

.. autoapisummary::

   AFQ.read_callosum_templates
   AFQ.read_templates
   AFQ.fetch_hcp
   AFQ.read_stanford_hardi_tractography
   AFQ.organize_stanford_data
   AFQ.make_bundle_dict



Attributes
~~~~~~~~~~

.. autoapisummary::

   AFQ.fetch_callosum_templates
   AFQ.fetch_templates
   AFQ.fetch_stanford_hardi_tractography
   AFQ._ga_id


.. data:: fetch_callosum_templates
   

   

.. function:: read_callosum_templates(resample_to=False)

   Load AFQ callosum templates from file



   :Returns:

       dict with: keys: names of template ROIs and values: nibabel Nifti1Image
           ..

       objects from each of the ROI nifti files.
           ..













   ..
       !! processed by numpydoc !!


.. data:: fetch_templates
   

   

.. function:: read_templates(resample_to=False)

   Load AFQ templates from file



   :Returns:

       dict with: keys: names of template ROIs and values: nibabel Nifti1Image
           ..

       objects from each of the ROI nifti files.
           ..













   ..
       !! processed by numpydoc !!


.. function:: fetch_hcp(subjects, hcp_bucket='hcp-openaccess', profile_name='hcp', path=None, study='HCP_1200', aws_access_key_id=None, aws_secret_access_key=None)

   Fetch HCP diffusion data and arrange it in a manner that resembles the
   BIDS [R8494a6c36190-1]_ specification.


   :Parameters:

       **subjects** : list
           Each item is an integer, identifying one of the HCP subjects

       **hcp_bucket** : string, optional
           The name of the HCP S3 bucket. Default: "hcp-openaccess"

       **profile_name** : string, optional
           The name of the AWS profile used for access. Default: "hcp"

       **path** : string, optional
           Path to save files into. Default: '~/AFQ_data'

       **study** : string, optional
           Which HCP study to grab. Default: 'HCP_1200'

       **aws_access_key_id** : string, optional
           AWS credentials to HCP AWS S3. Will only be used if `profile_name` is
           set to False.

       **aws_secret_access_key** : string, optional
           AWS credentials to HCP AWS S3. Will only be used if `profile_name` is
           set to False.

   :Returns:

       dict with remote and local names of these files,
           ..

       path to BIDS derivative dataset
           ..








   .. rubric:: Notes

   To use this function with its default setting, you need to have a
   file '~/.aws/credentials', that includes a section:

   [hcp]
   AWS_ACCESS_KEY_ID=XXXXXXXXXXXXXXXX
   AWS_SECRET_ACCESS_KEY=XXXXXXXXXXXXXXXX

   The keys are credentials that you can get from HCP
   (see https://wiki.humanconnectome.org/display/PublicData/How+To+Connect+to+Connectome+Data+via+AWS)  # noqa

   Local filenames are changed to match our expected conventions.

   .. [R8494a6c36190-1] Gorgolewski et al. (2016). The brain imaging data structure,
          a format for organizing and describing outputs of neuroimaging
          experiments. Scientific Data, 3::160044. DOI: 10.1038/sdata.2016.44.





   ..
       !! processed by numpydoc !!


.. data:: fetch_stanford_hardi_tractography
   

   

.. function:: read_stanford_hardi_tractography()

   Reads a minimal tractography from the Stanford dataset.
















   ..
       !! processed by numpydoc !!


.. function:: organize_stanford_data(path=None, clear_previous_afq=False)

   If necessary, downloads the Stanford HARDI dataset into DIPY directory and
   creates a BIDS compliant file-system structure in AFQ data directory:

   ~/AFQ_data/
   └── stanford_hardi
   ├── dataset_description.json
   └── derivatives
       ├── freesurfer
       │   ├── dataset_description.json
       │   └── sub-01
       │       └── ses-01
       │           └── anat
       │               ├── sub-01_ses-01_T1w.nii.gz
       │               └── sub-01_ses-01_seg.nii.gz
       └── vistasoft
           ├── dataset_description.json
           └── sub-01
               └── ses-01
                   └── dwi
                       ├── sub-01_ses-01_dwi.bval
                       ├── sub-01_ses-01_dwi.bvec
                       └── sub-01_ses-01_dwi.nii.gz

   If clear_previous_afq is True and there is an afq folder in derivatives,
   it will be removed.















   ..
       !! processed by numpydoc !!


.. class:: AFQ(bids_path, bids_filters={'suffix': 'dwi'}, dmriprep='all', custom_tractography_bids_filters=None, b0_threshold=50, patch2self=False, robust_tensor_fitting=False, min_bval=None, max_bval=None, reg_template='mni_T1', reg_subject='power_map', brain_mask=B0Mask(), mapping=SynMap(), profile_weights='gauss', bundle_info=None, dask_it=False, scalars=['dti_fa', 'dti_md'], virtual_frame_buffer=False, viz_backend='plotly_no_gif', tracking_params=None, segmentation_params=None, clean_params=None)


   Bases: :py:obj:`object`

   ..
       !! processed by numpydoc !!

   .. attribute:: gtab
      

      

   .. attribute:: dwi_affine
      

      

   .. attribute:: dwi_img
      

      

   .. attribute:: b0
      

      

   .. attribute:: brain_mask
      

      

   .. attribute:: dti
      

      

   .. attribute:: dti_fa
      

      

   .. attribute:: dti_cfa
      

      

   .. attribute:: dti_pdd
      

      

   .. attribute:: dti_md
      

      

   .. attribute:: dki
      

      

   .. attribute:: dki_mk
      

      

   .. attribute:: dki_fa
      

      

   .. attribute:: dki_md
      

      

   .. attribute:: dki_awf
      

      

   .. attribute:: mapping
      

      

   .. attribute:: streamlines
      

      

   .. attribute:: bundles
      

      

   .. attribute:: clean_bundles
      

      

   .. attribute:: tract_profiles
      

      

   .. attribute:: template_xform
      

      

   .. attribute:: bundle_dict
      

      

   .. method:: log_and_save_nii(self, img, fname)


   .. method:: log_and_save_trk(self, sft, fname)


   .. method:: _get_data_gtab(self, row, filter_b=True)


   .. method:: _b0(self, row)


   .. method:: _b0_mask(self, row)


   .. method:: _brain_mask(self, row)


   .. method:: _dti_fit(self, row)


   .. method:: _dti(self, row)


   .. method:: _dki_fit(self, row)


   .. method:: _dki(self, row)


   .. method:: _csd(self, row, response=None, sh_order=None, lambda_=1, tau=0.1, msmt=False)


   .. method:: _anisotropic_power_map(self, row)


   .. method:: _dti_fa(self, row)


   .. method:: _dti_cfa(self, row)


   .. method:: _dti_pdd(self, row)


   .. method:: _dti_md(self, row)


   .. method:: _dki_fa(self, row)


   .. method:: _dki_md(self, row)


   .. method:: _dki_awf(self, row, sphere='repulsion100', gtol=0.01)


   .. method:: _dki_mk(self, row)


   .. method:: _get_best_scalar(self)


   .. method:: _reg_img(self, img, mask, row=None)


   .. method:: _export_registered_b0(self, row)


   .. method:: _mapping(self, row)


   .. method:: _export_seed_mask(self, row)


   .. method:: _export_stop_mask(self, row)


   .. method:: _streamlines(self, row)


   .. method:: _segment(self, row)


   .. method:: _clean_bundles(self, row)


   .. method:: _tract_profiles(self, row)


   .. method:: _template_xform(self, row)


   .. method:: _export_rois(self, row)


   .. method:: _export_bundles(self, row)


   .. method:: _export_sl_counts(self, row)


   .. method:: _viz_prepare_vol(self, row, vol, xform, mapping)


   .. method:: _viz_prepare_vols(self, row, volume, xform_volume, color_by_volume, xform_color_by_volume)


   .. method:: _viz_bundles(self, row, export=False, inline=False, interactive=False, volume=None, xform_volume=False, color_by_volume=None, cbv_lims=[None, None], xform_color_by_volume=False, volume_opacity=0.3, n_points=40)


   .. method:: _viz_ROIs(self, row, bundle_names=None, export=False, inline=False, interactive=False, volume=None, xform_volume=False, color_by_volume=None, cbv_lims=[None, None], xform_color_by_volume=False, volume_opacity=0.3, n_points=40)


   .. method:: _plot_tract_profiles(self, row)


   .. method:: _export_timing(self, row, all_sub_sess=None)


   .. method:: _get_affine(self, fname)


   .. method:: _get_fname(self, row, suffix, include_track=False, include_seg=False)


   .. method:: set_gtab(self, b0_threshold)


   .. method:: get_gtab(self)


   .. method:: set_dwi_affine(self)


   .. method:: get_dwi_affine(self)


   .. method:: set_dwi_img(self)


   .. method:: get_dwi_img(self)


   .. method:: __getitem__(self, k)


   .. method:: set_b0(self)


   .. method:: get_b0(self)


   .. method:: set_masked_b0(self)


   .. method:: get_masked_b0(self)


   .. method:: set_brain_mask(self)


   .. method:: get_brain_mask(self)


   .. method:: set_dti(self)


   .. method:: get_dti(self)


   .. method:: set_dti_fa(self)


   .. method:: get_dti_fa(self)


   .. method:: set_dti_cfa(self)


   .. method:: get_dti_cfa(self)


   .. method:: set_dti_pdd(self)


   .. method:: get_dti_pdd(self)


   .. method:: set_dti_md(self)


   .. method:: get_dti_md(self)


   .. method:: set_dki(self)


   .. method:: get_dki(self)


   .. method:: set_dki_mk(self)


   .. method:: get_dki_mk(self)


   .. method:: set_dki_fa(self)


   .. method:: get_dki_fa(self)


   .. method:: set_dki_md(self)


   .. method:: get_dki_md(self)


   .. method:: set_dki_awf(self)


   .. method:: get_dki_awf(self)


   .. method:: set_mapping(self)


   .. method:: get_mapping(self)


   .. method:: set_streamlines(self)


   .. method:: get_streamlines(self)


   .. method:: set_bundles(self)


   .. method:: get_bundles(self)


   .. method:: set_clean_bundles(self)


   .. method:: get_clean_bundles(self)


   .. method:: set_tract_profiles(self)


   .. method:: get_tract_profiles(self)


   .. method:: set_template_xform(self)


   .. method:: get_template_xform(self)


   .. method:: set_bundle_dict(self)


   .. method:: get_bundle_dict(self)


   .. method:: export_rois(self)


   .. method:: export_seed_mask(self)


   .. method:: export_stop_mask(self)


   .. method:: export_bundles(self)


   .. method:: export_sl_counts(self)


   .. method:: viz_bundles(self, export=False, volume=None, xform_volume=False, color_by_volume=None, cbv_lims=[None, None], xform_color_by_volume=False, volume_opacity=0.3, n_points=40, inline=False, interactive=False)


   .. method:: viz_ROIs(self, bundle_names=None, export=False, volume=None, xform_volume=False, color_by_volume=None, cbv_lims=[None, None], xform_color_by_volume=False, volume_opacity=0.3, n_points=40, inline=False, interactive=False)


   .. method:: plot_tract_profiles(self)


   .. method:: export_registered_b0(self)


   .. method:: combine_profiles(self)


   .. method:: export_timing(self, all_sub_sess=None)


   .. method:: export_all(self)

      Exports all the possible outputs
















      ..
          !! processed by numpydoc !!


   .. method:: upload_to_s3(self, s3fs, remote_path)

      Upload entire AFQ derivatives folder to S3
















      ..
          !! processed by numpydoc !!



.. function:: make_bundle_dict(bundle_names=BUNDLES, seg_algo='afq', resample_to=False)

   Create a bundle dictionary, needed for the segmentation


   :Parameters:

       **bundle_names** : list, optional
           A list of the bundles to be used in this case. Default: all of them

       **seg_algo: One of {"afq", "reco", "reco16", "reco80"}**
           The bundle segmentation algorithm to use.
               "afq" : Use waypoint ROIs + probability maps, as described
               in [Yeatman2012]_
               "reco" / "reco16" : Use Recobundles [Garyfallidis2017]_
               with a 16-bundle set.
               "reco80": Use Recobundles with an 80-bundle set.

       **resample_to** : Nifti1Image, optional
           If set, templates will be resampled to the affine and shape of this
           image.














   ..
       !! processed by numpydoc !!


.. data:: _ga_id
   :annotation: = UA-156363454-3

   

